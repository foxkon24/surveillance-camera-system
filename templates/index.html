<!DOCTYPE html>
<html lang="ja">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, shrink-to-fit=no, user-scalable=no">
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.5.18/hls.js"></script>
    <title>監視カメラシステム</title>
    <script>
        // 10分間隔でページを自動更新する関数
        function setupAutoRefresh() {
            setInterval(function() {
                // ユーザーが操作しているかどうかを確認
                const userActivity = sessionStorage.getItem('userActivity');
                const now = Date.now();
                
                // 最後のユーザー操作から3分以上経過している場合のみリロード
                if (!userActivity || (now - userActivity > 180000)) {
                    location.reload();
                }
            }, 600000); // 10分 = 600000ミリ秒
        }

        // ユーザーの操作を検知する
        function detectUserActivity() {
            document.addEventListener('click', updateUserActivity);
            document.addEventListener('keypress', updateUserActivity);
            document.addEventListener('scroll', updateUserActivity);
            document.addEventListener('mousemove', throttle(updateUserActivity, 60000)); // 1分間隔で更新
        }

        // ユーザーアクティビティタイムスタンプを更新
        function updateUserActivity() {
            sessionStorage.setItem('userActivity', Date.now());
        }

        // スロットル関数（高頻度イベントの制限）
        function throttle(func, delay) {
            let lastCall = 0;
            return function() {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func.apply(this, arguments);
                }
            };
        }

        // ページ読み込み完了時に自動更新とユーザー操作検知を設定
        window.addEventListener('load', function() {
            setupAutoRefresh();
            detectUserActivity();
            updateUserActivity(); // 初期値を設定
        });
    </script>
</head>
<body>
    <div class="layout">
        <header><h1>監視カメラシステム</h1></header>
        <nav>
            <ul>
                <li><a href="/system/cam/">Top</a></li>
                <li><a href="/system/cam/record/">録画データ</a></li>
                <li><a href="/system/cam/backup/">バックアップ録画一覧</a></li>
            </ul>
        </nav>
        <div class="container">
            <div class="grid">
                {% for camera in cameras %}
                    <div class="camera">
                        <h4>{{ camera.name }}</h4>
                        <div class="video-wrapper">
                            <video id="video{{ camera.id }}" autoplay playsinline muted style="width: 320px; height: 240px;"></video>
                            <div class="stream-status" id="status{{ camera.id }}"></div>
                        </div>
                    </div>
                {% endfor %}
            </div>
        </div>
        <footer>&nbsp;&nbsp;Copyright&copy;&nbsp;&nbsp;2024&nbsp;&nbsp;株式会社&nbsp;共立電機製作所&nbsp;&nbsp;All&nbsp;rights&nbsp;reserved.</footer>
    </div>
    <script>
        const players = {};
        const retryAttempts = {};
        const streamTimestamps = {};  // ストリームデータの最終受信時間を追跡
        const streamErrors = {};      // エラー回数を追跡
        const lastPlayTime = {};      // 最後に再生していた時間を追跡
        const MAX_RETRY_ATTEMPTS = 3;
        const RETRY_DELAY = 2000;
        const STREAM_CHECK_INTERVAL = 5000;  // 5秒ごとにストリームをチェック
        const STREAM_STALL_TIMEOUT = 10000;  // 10秒間データが来なければ停止とみなす
        let pageActive = true;        // ページがアクティブかどうか

        function updateStreamStatus(cameraId, status) {
            const statusElement = document.getElementById('status' + cameraId);
            if (statusElement) {
                statusElement.textContent = status;
                
                // ステータスに応じて表示スタイルを変更
                if (status === '接続済') {
                    statusElement.style.color = 'green';
                } else if (status === 'エラー発生' || status.includes('再読み込み')) {
                    statusElement.style.color = 'red';
                } else if (status === 'バッファリング中...' || status.includes('再接続')) {
                    statusElement.style.color = 'orange';
                } else {
                    statusElement.style.color = 'gray';
                }
            }
        }

        function reloadStream(cameraId) {
            if (streamErrors[cameraId] >= 3) {
                // エラーが多すぎる場合、より長い待機時間を設ける
                const currentTime = Date.now();
                const lastErrorTime = streamErrors[cameraId + '_time'] || 0;
                
                if (currentTime - lastErrorTime < 30000) { // 30秒以内に再試行済み
                    updateStreamStatus(cameraId, '接続エラー - 後で再試行します');
                    console.log(`Too many errors for camera ${cameraId}, will retry later`);
                    
                    // 1分後に自動リトライ
                    setTimeout(() => {
                        streamErrors[cameraId] = 0;
                        initializePlayer(cameraId);
                    }, 60000);
                    
                    return;
                }
                
                // 30秒以上経過していれば再試行
                streamErrors[cameraId] = 0;
            }
            
            // エラー回数記録
            streamErrors[cameraId] = (streamErrors[cameraId] || 0) + 1;
            streamErrors[cameraId + '_time'] = Date.now();
            
            console.log(`Reloading stream for camera ${cameraId}`);
            updateStreamStatus(cameraId, '再読み込み中...');
            
            if (players[cameraId]) {
                players[cameraId].destroy();
                players[cameraId] = null;
            }
            
            // 少し待ってから再初期化
            setTimeout(() => initializePlayer(cameraId), RETRY_DELAY);
        }

        function initializePlayer(cameraId) {
            const video = document.getElementById('video' + cameraId);
            if (!video) return;
            
            const filePath = '/system/cam/tmp/' + cameraId + '/' + cameraId + '.m3u8';

            if (players[cameraId]) {
                try {
                    players[cameraId].destroy();
                } catch (e) {
                    console.log(`Error destroying player for camera ${cameraId}:`, e);
                }
                players[cameraId] = null;
            }

            retryAttempts[cameraId] = 0;
            streamTimestamps[cameraId] = Date.now();  // 初期化時のタイムスタンプを記録
            updateStreamStatus(cameraId, '接続中...');

            if (Hls.isSupported()) {
                const hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 10,    // バックバッファを減らす
                    maxBufferLength: 5,      // バッファ長を短くして遅延を減らす
                    maxMaxBufferLength: 10,  // 最大バッファ長も短く
                    manifestLoadingTimeOut: 5000,   // タイムアウトも短く
                    manifestLoadingMaxRetry: 2,     // リトライ回数を減らす
                    levelLoadingTimeOut: 5000,
                    levelLoadingMaxRetry: 2,
                    fragLoadingTimeOut: 5000,
                    fragLoadingMaxRetry: 2,
                    // 追加のオプション
                    capLevelToPlayerSize: true,     // プレイヤーサイズに合わせてレベルを制限
                    startLevel: -1,                 // 自動選択(-1)
                    defaultAudioCodec: 'mp4a.40.2', // 標準的なAACコーデック指定
                    progressive: false,             // 通常のHLSストリーミング
                    maxBufferHole: 0.5,             // バッファホールの最大サイズを小さく
                    highBufferWatchdogPeriod: 2,    // 高バッファウォッチドッグの期間を短く
                    nudgeMaxRetry: 5,               // 最大ヌッジリトライ回数
                    xhrSetup: function(xhr) {
                        xhr.addEventListener('error', function() {
                            console.log(`Camera ${cameraId} xhr error occurred`);
                        });
                    }
                });

                players[cameraId] = hls;
                
                // エラーハンドラを先に設定
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.log(`Camera ${cameraId} HLS error:`, data);

                    if (data.fatal) {
                        updateStreamStatus(cameraId, 'エラー発生');

                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log(`Camera ${cameraId} network error, attempting recovery...`);
                                if (retryAttempts[cameraId] < MAX_RETRY_ATTEMPTS) {
                                    retryAttempts[cameraId]++;
                                    updateStreamStatus(cameraId, '再接続中...');
                                    setTimeout(() => {
                                        if (hls && typeof hls.startLoad === 'function') {
                                            hls.startLoad();
                                        }
                                    }, RETRY_DELAY);
                                } else {
                                    // 最大再試行回数を超えたら再読み込み
                                    reloadStream(cameraId);
                                }
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log(`Camera ${cameraId} media error, attempting recovery...`);
                                try {
                                    hls.recoverMediaError();
                                } catch (e) {
                                    reloadStream(cameraId);
                                }
                                break;
                            default:
                                if (retryAttempts[cameraId] < MAX_RETRY_ATTEMPTS) {
                                    retryAttempts[cameraId]++;
                                    setTimeout(() => initializePlayer(cameraId), RETRY_DELAY);
                                } else {
                                    // 最大再試行回数を超えたら再読み込み
                                    reloadStream(cameraId);
                                }
                                break;
                        }
                    }
                });
                
                // m3u8ファイルのロード
                hls.loadSource(filePath);
                hls.attachMedia(video);

                // メディアがアタッチされたら再生
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    try {
                        video.play().catch(function(error) {
                            console.log(`Camera ${cameraId} autoplay failed:`, error);
                            video.muted = true;
                            video.play().catch(function(innerError) {
                                console.log(`Camera ${cameraId} muted play failed:`, innerError);
                            });
                        });
                        updateStreamStatus(cameraId, '接続済');
                    } catch (e) {
                        console.log(`Camera ${cameraId} play error:`, e);
                    }
                });

                // フラグメントロード成功時にタイムスタンプを更新
                hls.on(Hls.Events.FRAG_LOADED, function() {
                    streamTimestamps[cameraId] = Date.now();
                    retryAttempts[cameraId] = 0; // フラグメントが正常にロードされたらリセット
                    
                    // 正常に再生中であることを確認
                    if (video && !video.paused) {
                        lastPlayTime[cameraId] = video.currentTime;
                    }
                });
                
                // メディアの再接続イベント
                hls.on(Hls.Events.BUFFER_APPENDED, function() {
                    if (video.paused && pageActive) {
                        try {
                            video.play().catch(function(error) {
                                console.log(`Camera ${cameraId} resume play failed:`, error);
                            });
                        } catch (e) {}
                    }
                });

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari用のフォールバック
                video.src = filePath;
                video.addEventListener('loadedmetadata', function() {
                    try {
                        video.play().catch(function(error) {
                            console.log(`Camera ${cameraId} Safari autoplay failed:`, error);
                            video.muted = true;
                            video.play().catch(function(innerError) {
                                console.log(`Camera ${cameraId} Safari muted play failed:`, innerError);
                            });
                        });
                        updateStreamStatus(cameraId, '接続済');
                    } catch (e) {
                        console.log(`Camera ${cameraId} Safari play error:`, e);
                    }
                });
                
                // Safari用の監視
                video.addEventListener('playing', function() {
                    streamTimestamps[cameraId] = Date.now();
                    lastPlayTime[cameraId] = video.currentTime;
                });
                
                video.addEventListener('error', function(e) {
                    console.log(`Camera ${cameraId} Safari video error:`, e);
                    reloadStream(cameraId);
                });
            }
        }

        // ストリーミングの健全性チェック
        function setupHealthChecks() {
            {% for camera in cameras %}
            setInterval(() => {
                if (!pageActive) return; // ページが非アクティブならチェックしない
                
                const cameraId = '{{ camera.id }}';
                const video = document.getElementById('video' + cameraId);
                const currentTime = Date.now();
                const lastUpdateTime = streamTimestamps[cameraId] || 0;
                
                if (!video) return;
                
                // 再生状態チェック - readyState 0はストリームが読み込まれていない状態
                if (video.readyState === 0) {
                    console.log(`Camera ${cameraId} stream not loaded, attempting recovery...`);
                    updateStreamStatus(cameraId, '再接続中...');
                    reloadStream(cameraId);
                    return;
                }
                
                // データ受信チェック - 一定時間データが来ていなければ再接続
                if (currentTime - lastUpdateTime > STREAM_STALL_TIMEOUT) {
                    console.log(`Camera ${cameraId} stream stalled (no data for ${(currentTime - lastUpdateTime)/1000}s), reloading...`);
                    updateStreamStatus(cameraId, 'データ停止 - 再読み込み中...');
                    reloadStream(cameraId);
                    return;
                }
                
                // 再生が進んでいるかチェック
                const currentPlayTime = video.currentTime;
                const lastPlay = lastPlayTime[cameraId] || 0;
                
                if (!video.paused && lastPlay > 0 && currentPlayTime === lastPlay) {
                    // 再生位置が変わっていない = スタックしている可能性
                    console.log(`Camera ${cameraId} playback stuck at ${currentPlayTime}, attempting recovery...`);
                    updateStreamStatus(cameraId, '再生停止 - 回復中...');
                    
                    // HLS.jsが利用可能な場合は再生を試みる
                    if (players[cameraId]) {
                        try {
                            // レベルスイッチを試す
                            if (players[cameraId].currentLevel !== -1) {
                                players[cameraId].currentLevel = -1;
                            }
                            
                            // 少し巻き戻してみる
                            video.currentTime = Math.max(0, currentPlayTime - 1);
                            
                            // 再生を試みる
                            video.play().catch(e => {
                                console.log(`Camera ${cameraId} recovery play failed:`, e);
                                reloadStream(cameraId);
                            });
                        } catch (e) {
                            console.log(`Camera ${cameraId} recovery error:`, e);
                            reloadStream(cameraId);
                        }
                    } else {
                        reloadStream(cameraId);
                    }
                } else if (!video.paused) {
                    // 再生位置が変わっている = 正常に再生中
                    lastPlayTime[cameraId] = currentPlayTime;
                }
                
                // バッファリングチェック
                if (!video.paused && video.readyState > 1 && video.played.length > 0) {
                    if (video.buffered.length > 0) {
                        const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                        const bufferedTime = bufferedEnd - video.currentTime;
                        
                        // バッファリング時間が極端に短い場合はストリームが詰まっている可能性
                        if (bufferedTime < 0.3 && video.readyState < 4) {
                            console.log(`Camera ${cameraId} low buffer (${bufferedTime.toFixed(2)}s), may be stalling`);
                            updateStreamStatus(cameraId, 'バッファリング中...');
                        }
                    }
                }
            }, STREAM_CHECK_INTERVAL);
            {% endfor %}
        }

        // 健全性ポーリング（サーバーに接続できることを確認）
        function pingServer() {
            setInterval(() => {
                if (!pageActive) return;
                
                fetch('/system/cam/', { method: 'HEAD' })
                    .then(response => {
                        if (!response.ok) {
                            console.log('Server ping failed, response not OK');
                        }
                    })
                    .catch(error => {
                        console.log('Server ping error:', error);
                    });
            }, 60000); // 1分ごとにサーバーをping
        }

        window.onload = function() {
            {% for camera in cameras %}
                initializePlayer('{{ camera.id }}');
            {% endfor %}
            
            // 健全性チェックとサーバーポーリングを設定
            setupHealthChecks();
            pingServer();
        };

        // バックグラウンド切り替え時の処理
        document.addEventListener('visibilitychange', function() {
            pageActive = !document.hidden;
            
            if (document.hidden) {
                // バックグラウンドに移行した場合、各ストリームを一時停止
                for (const cameraId in players) {
                    if (players[cameraId]) {
                        try {
                            players[cameraId].stopLoad();
                            updateStreamStatus(cameraId, '一時停止');
                        } catch (e) {}
                    }
                }
            } else {
                // フォアグラウンドに戻った場合、各ストリームを再開
                for (const cameraId in players) {
                    if (players[cameraId]) {
                        try {
                            players[cameraId].startLoad();
                            streamTimestamps[cameraId] = Date.now(); // タイムスタンプを更新
                            updateStreamStatus(cameraId, '再開中...');
                            
                            // ビデオ要素を取得
                            const video = document.getElementById('video' + cameraId);
                            if (video) {
                                video.play().catch(e => {
                                    console.log(`Camera ${cameraId} resume play failed:`, e);
                                });
                            }
                        } catch (e) {
                            // エラーが発生したら再初期化
                            console.log(`Camera ${cameraId} resume error:`, e);
                            initializePlayer(cameraId);
                        }
                    } else {
                        initializePlayer(cameraId);
                    }
                }
            }
        });

        // クリーンアップ
        window.addEventListener('beforeunload', function() {
            for (const cameraId in players) {
                if (players[cameraId]) {
                    try {
                        players[cameraId].destroy();
                    } catch (e) {}
                }
            }
        });
    </script>
</body>
</html>
